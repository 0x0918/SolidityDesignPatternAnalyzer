\chapter{Classificazione dei Design Pattern per Smart-Contract}
I design pattern adottati nello sviluppo di smart-contract possono essere classificati in diversi tipi\cite[alcuni tipi]{9089272}\cite{9050163}, ognuno dei quali caratterizza un aspetto specifico della lifecycle del contratto:

\begin{itemize}
	\item \textit{Authorization}: relativi alla gestione dell'accesso alle funzionalità del contratto;
	\item \textit{Behavioral}: relativi a meccanismi di supporto per il corretto svolgimento delle funzionalità del contratto;
	\item \textit{Gas Economic}: relativi a meccanismi per ridurre il consumo di \textit{gas} durante l'esecuzione delle funzionalità del contratto;
	\item \textit{Lifecycle}: relativi alla a meccanismi per la creazione e la distruzione del contratto;
	\item \textit{Maintenance}: relativi a meccanismi di supporto per la manutenzione del contratto;
	\item \textit{Security}: relativi a meccanismi per la mitigazione di vulnerabilità di sicurezza note;
\end{itemize}

{\section{Authorization Design Pattern}
La blockchain Ethereum non implementa meccanismi di autenticazione o di permessi per consentire l'accesso alle funzionalità di un contratto solo nel caso in cui vengano soddisfatte determinate condizioni. Per la natura della blockchain, ogni funzione definita con visibilità pubblica può essere invocata da qualsiasi utente.\par
Gli \textit{Authorization Design Pattern} propongono meccanismi atti a limitare l'esecuzione delle funzionalità di un contratto.\par
Si individuano i seguenti design pattern: \textit{Access Restriction} e \textit{Ownership}.

{\subsection{Access Restriction Pattern}
	L’\textit{Access Restriction} pattern propone un meccanismo per introdurre dei controlli di prerequisiti nella logica del contratto.\par
	Il meccanismo proposto si basa sul concetto di \textit{function modifiers} presente in Solidity, che ci permette di definire controlli che possono essere eseguiti prima o dopo l'esecuzione del corpo della funzione a cui viene assegnato il modifier.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Qualsiasi utente può richiamare qualunque funzione definita con visibilità pubblica di un contratto, ma in certi use-case potrebbe essere necessario definire dei prerequisiti o condizioni ed eseguire la funzionalità solo al verificarsi di essi.} \\ \hline
					\textbf{Soluzione} & {Definire una serie di \textit{modifier} generalmente applicabili che controllano i prerequisiti desiderati e inserirli nella definizione delle funzioni interessate.} \\ \hline
					\textbf{Riconoscimento} & {Individuare  all'interno del contratto l'utilizzo o la definizione dei \textit{modifier}.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:access_restriction]{Appendice}.  \\ \hline
					\textbf{Riferimenti} & \cite[Access Restriction]{maxwoe} \cite[Access Restriction]{cjgdev} \cite[Access Restriction]{fravoll} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Access Restriction Pattern}
	\end{table}
}
\newpage
{\subsection{Ownership Pattern}
L’\textit{Ownership} pattern propone un meccanismo per riservare al proprietario di uno smart-contract l’esecuzione di funzionalità critiche, a cui l’utente finale non deve avere accesso.\par
Opzionalmente possono essere implementati anche meccanismi di supporto per eseguire l’operazione di trasferimento del titolo di proprietario.
Può essere considerato un caso specifico di Access Restriction.
\begin{table}[H]
	\centering
	\begin{tikzpicture}
		\node (table) [inner sep=0pt] {
			\def\arraystretch{1.5}
			\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
				\textbf{Problema} & {Qualsiasi utente può richiamare qualunque funzione definita con visibilità pubblica di un contratto, ma in certi use-case potrebbe essere necessario riservare l’esecuzione di specifiche funzioni al solo proprietario.} \\ \hline
				\textbf{Soluzione} & {Memorizzare in una variabile di stato del contratto l'indirizzo del proprietario e limitare l'esecuzione delle funzioni in base all'indirizzo del chiamante.} \\ \hline
				\textbf{Riconoscimento} & {Individuare un confronto fra \textit{msg.sender} e la variabile di stato contenente l’indirizzo del proprietario.\par Il confronto può essere implementato all'interno della funzione di interesse attraverso un costrutto \textit{if-else}, \textit{modifier} o la funzione \textit\mbox{\textit{require()}}.} \\ \hline
				\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:ownership]{Appendice}.  \\ \hline
				\textbf{Riferimenti} & \cite[Ownership]{maxwoe} \cite[Ownership]{cjgdev} \cite[Incluso in Access Restriction]{fravoll} \\
			\end{tabular}
		};
		\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
	\end{tikzpicture}
	\caption{Specifiche Ownership Pattern}
\end{table}
}
}

{\section{Behavioral Design Pattern}
I Behavioral design pattern propongono funzionalità e meccanismi di supporto per lo svolgimento delle operazioni del contratto.\par
Si individuano i seguenti design pattern: \textit{Commit \& Reveal}, \textit{Guard Check}, \textit{Oracle}, \textit{Pull Payment (Pull over Push)}, \textit{Randomness} e \textit{State Machine Pattern}.
{\subsection{Commit and Reveal Pattern}
	Il \textit{Commit and Reveal} pattern propone un meccanismo per consentire agli utenti di uno smart-contract di attenersi a un valore tenendolo nascosto agli altri con la possibilità di rivelarlo in seguito.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Essendo Ethereum una blockchain pubblica, tutti i dati e tutte le transazioni sono visibili pubblicamente. Si può facilmente immaginare un caso d’uso, come una scommessa basata sul gioco carta-forbici-sasso, in cui le interazioni con lo smart-contract, particolarmente i valori dei parametri inviati, debbano essere trattate in modo confidenziale.} \\ \hline
					\textbf{Soluzione} & {Implementare uno schema di commitment. Uno schema di commitment è un algoritmo crittografico utilizzato per consentire a qualcuno di impegnarsi su un valore tenendolo nascosto ad altri con la possibilità di rivelarlo in seguito. I valori in uno schema di commitment sono vincolanti, ovvero nessuno può cambiarli una volta impegnati. Lo schema prevede due fasi: una fase di commit in cui viene scelto e specificato un valore e una fase di reveal in cui il valore viene rivelato e utilizzato.} \\ \hline
					\textbf{Riconoscimento} & {Data la complessità e la libertà implementativa, il riconoscimento di questo design pattern si basa sulla ricerca di definizione e uso di funzioni denominate \textit{commit} e \textit{reveal} e sulla definizione degli eventi \textit{LogCommit} e \textit{LogReveal}. Si potrebbe affinare il riconoscimento tentanto di rilevare una struct di commit.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:commit_and_reveal]{Appendice}.  \\ \hline
					\textbf{Riferimenti} & \cite[CommitReveal]{maxwoe} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Commit and Reveal Pattern}
	\end{table}
}
{\subsection{Guard Check}
	Il \textit{Guard Check} pattern propone un meccanismo per assicurarsi che il 
	comportamento dello smart-contract sia quello previsto, che i parametri di input siano validi e che in caso di errore lo stato interno del contratto venga ripristinato al momento precedente l'esecuzione della funzione.\par
	Potremmo immaginare questo design pattern come una implementazione di numerosi test eseguiti a runtime per valutare lo stato d’esecuzione.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Nella blockchain Ethereum non vi sono regolatori o mediatori, ma vi è bisogno di protezioni o controlli per assicurare che la logica degli smart-contract funzioni come specificato. Uno smart-contract dovrebbe verificare tutti i prerequisiti della funzionalità richiesta e procedere solo se tutto è come previsto. In caso di errori, il contratto dovrebbe ripristinare tutte le modifiche apportate al suo stato.} \\ \hline
					\textbf{Soluzione} & {Per ottenere questi comportamenti, Solidity sfrutta il modo in cui l'EVM gestisce gli errori: per mantenere l'atomicità, tutte le modifiche effettuate vengono annullate e l'intera transazione viene invalidata. Per innescare gli errori, e quindi ripristinare lo stato interno del contratto, Solidity utilizza una serie di eccezioni, ognuna avente un utilizzo specifico:
					\begin{itemize}
						\item \textit{assert(condition)}: usato solo per verificare la presenza di errori interni e per controllare gli invarianti (asserzioni sempre vere). Una caratteristica importante è che rimborsa tutto il gas che non è stato consumato nel momento in cui viene lanciata l'eccezione;
						\item \textit{require(condition)}: usato solo per garantire condizioni valide, come gli input o le variabili di stato del contratto, o per convalidare i valori di ritorno da chiamate a contratti esterni. Una caratteristica importante è che consuma tutto il gas incluso nella transazione;
						\item \textit{revert()}: usato per ripristinare le modifiche apportate allo stato, viene normalmente lanciato automaticamente in caso di fallimento da \textit{require()} o \textit{assert()} ma potrebbe essere utilizzato all’interno di un controllo fatto da un costrutto \textit{if};
					\end{itemize}} \\ \hline
					\textbf{Riconoscimento} & {Individuare l'utilizzo di una delle eccezioni: \textit{assert(condition)}, \textit{require(condition)} o \textit{revert()}.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:guardcheck]{Appendice}.  \\ \hline
					\textbf{Riferimenti} & \cite[Guard Check]{fravoll} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Guard Check Pattern}
	\end{table}
}
{\subsection{Oracle Pattern}
	L’\textit{Oracle} pattern propone un meccanismo per permettere a un contratto di ottenere informazioni dal mondo esterno, fuori dalla blockchain, necessarie al corretto funzionamento del contratto e non presenti all'interno della rete Ethereum.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Si immagini un caso d’uso in cui lo smart-contract necessiti di informazioni presenti al di fuori della blockchain, come ad esempio l'attuale cambio di una specifica valuta. Gli smart-contract Ethereum non possono acquisirle direttamente poiché non possono contattare il mondo esterno, al contrario si affidano al mondo esterno che immette tali informazioni nella rete.} \\ \hline
					\textbf{Soluzione} & {Richiedere i dati esterni attraverso un servizio \textit{oracolo}, un mediatore collegato al mondo esterno che assume il ruolo di provider di dati.} \\ \hline
					\textbf{Riconoscimento} & {Data la complessità e la libertà implementativa, il riconoscimento di questo design pattern si basa sulla ricerca di definizione e uso di funzioni denominate \textit{query} e \textit{reply} e sulla definizione di eventi relativi alle richieste. Si potrebbe affinare il riconoscimento tentanto di rilevare una struct di richieste. } \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:oracle]{Appendice}  \\ \hline
					\textbf{Riferimenti} & \cite[Oracle]{maxwoe} \cite[Variante basata su Oraclize]{fravoll} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Oracle Pattern}
	\end{table}
}
\newpage
{\subsection{Full Payment (Pull Over Push) Pattern}
	Il \textit{Full Payment (Pull Over Push)} pattern propone un meccanismo per eseguire 
	pagamenti (trasferimenti di criptovaluta) in modo sicuro.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {L'invio di \textit{ether} comporta una chiamata all'entità ricevente. Tale chiamata esterna potrebbe fallire per diversi motivi: per esempio se l'indirizzo ricevente è un contratto, potrebbe essere implementata una funzione di \textit{fallback()} che lancia semplicemente un'eccezione, una volta chiamata. Un altro causa di fallimento potrebbe essere l'esaurimento del “gas” contenuto nella transazione.} \\ \hline
					\textbf{Soluzione} & {Mai non affidarsi al fatto che le chiamate esterne vengano eseguite senza lanciare un errore: potremmo dire che è responsabilità del destinatario assicurarsi di essere in grado di ricevere il denaro. Per questo motivo la situazione ideale è far sì che sia il destinatario a innescare il trasferimento.} \\ \hline
					\textbf{Riconoscimento} & {Individuare un trasferimento di \textit{ether} ad opera del destinatario, ovvero una chiamata a funzione del tipo: \textit{msg.sender.transfer(amount)}.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:pull_over_push]{Appendice}  \\ \hline
					\textbf{Riferimenti} & \cite[SendingFunds]{maxwoe} \cite[Pull Over Push]{fravoll} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Full Payment (Pull Over Push) Pattern}
	\end{table}
}
{\subsection{Randomness Pattern}
	Il \textit{Randomness} pattern propone un meccanismo per consentire a uno smart-contract di generare un numero casuale, appartenente a un intervallo predefinito, in un ambiente deterministico come la blockchain.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {La casualità nei sistemi informatici, e soprattutto in Ethereum, è notoriamente difficile da ottenere. Per quanto riguarda Ethereum, la rete è una macchina di Turing deterministica, senza alcuna casualità intrinseca ma, nonostante ciò, la necessità di casualità è assai elevata, si immagini un gioco la cui vincita si basa su un fattore di casualità. Un’altra problematica per la casualità è la natura pubblica di una blockchain: lo stato interno di un contratto, così come l'intera storia di una blockchain, è visibile al pubblico. Pertanto, è difficile trovare una fonte sicura di entropia.} \\ \hline
					\textbf{Soluzione} & {Sono state ideate diverse soluzioni per superare queste limitazioni:
					\begin{itemize}
						\item \textit{Block Hash PRNG}: l'hash del blocco viene usato come sorgente di casualità;
						\item \textit{Oracle PRNG}: un oracolo assume il ruolo di provider di casualità;
						\item \textit{Collaborative PRNG}: una generazione collaborativa di casualità dentro la blockchain;
					\end{itemize}
					} \\ \hline
					\textbf{Riconoscimento} & {Data la complessità e la libertà implementativa delle varianti basate sull'oracolo e la generazione collaborativa, si riconosce la variane più semplice basata sull'hash del blocco. L'hash del blocco può essere usato in diversi modi:
					\begin{itemize}
						\item \textit{uint(blockhash(block.number-1))}: non utilizzabile per scommesse in quanto facilmente determinabile;
						\item \textit{uint(keccak256(abi.encodePacked(blockhash( block.number-1), seed)))}: il seed viene generato dall'utente e fornito come parametro;
						\item \textit{uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, block.difficulty)))}
					\end{itemize}
					} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:randomness]{Appendice}  \\ \hline
					\textbf{Riferimenti} & \cite[Randomness]{fravoll} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Randomness Pattern}
	\end{table}
}
{\subsection{State Machine Pattern}
	Lo \textit{State Machine} pattern propone un meccanismo per consentire a uno smart-contract di passare, durante la sua esecuzione, attraverso diverse fasi con diverse funzionalità corrispondenti esposte.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Consideriamo un contratto che deve passare da uno stato iniziale, attraverso diversi stati intermedi, allo stato finale nel corso della sua attività. In ognuno di questi stati il contratto deve comportarsi in modo diverso e fornire diverse funzionalità ai suoi utenti. Il comportamento descritto può essere osservato in una moltitudine di casi d'uso: aste, gioco d'azzardo, crowdfunding, ect...} \\ \hline
					\textbf{Soluzione} & {Implementare una macchina a stati per modellare e rappresentare le diverse fasi comportamentali del contratto e le loro transizioni.} \\ \hline
					\textbf{Riconoscimento} & {Data la complessità e la libertà implementativa, il riconoscimento di questo design pattern si basa sulla ricerca di definizione e uso di un \textit{modifier} relativo agli stati e la definizione di un \textit{enum} di stati.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:state_machine]{Appendice}  \\ \hline
					\textbf{Riferimenti} & \cite[StateMachine]{maxwoe} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche State Machine Pattern}
	\end{table}
}
}

{\section{Gas Economic Design Pattern}
	I Gas Economic design pattern propongono meccanismi considerabili come \textit{best practice} per ridurre il consumo di gas durante l’esecuzione delle funzionalità dello smart-contract. \par
	Le operazioni con un consumo di gas altamente variabile e imprevedibile costituiscono un problema per i contratti, in quanto comportano il rischio che le transazioni rimangano senza gas e si ottengano di conseguenza dei comportamenti indesiderati. Pertanto, è auspicabile un fabbisogno di gas basso, stabile e prevedibile.\par
	Si individuano i seguenti design pattern: \textit{Memory Array Building}, \textit{String Equality Comparison} e \textit{Tight Variable Packing}.
	
	{\subsection{Memory Array Building Pattern}
		Il \textit{Memory Array Building} pattern propone un meccanismo per aggregare e recuperare i dati dallo storage di un contratto in modo efficiente dal punto di vista del consumo di gas.\par	L'interazione con lo storage di un contratto sulla blockchain è una delle operazioni più costose dell'EVM. Pertanto, è necessario memorizzare solo i dati necessari ed evitare, se possibile, la ridondanza. Nei sistemi tradizionali l'unico costo rilevante delle query in uno storage è il tempo, mentre in Ethereum anche semplici interrogazioni possono costare una quantità sostanziale di gas, che ha un riscontro monetario diretto.\par
		Si potrebbe mitigare il costo del gas relativo alla lettura di un dato definendo la variabile contenitore come pubblica, generando così un \textit{getter} in background che permette di accedere gratuitamente al valore della variabile, ma ciò non è sempre applicabile.
		\begin{table}[H]
			\centering
			\begin{tikzpicture}
				\node (table) [inner sep=0pt] {
					\def\arraystretch{1.5}
					\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
						\textbf{Problema} & {Si immagini un caso d’uso in cui si voglia aggregare dati provenienti da diverse fonti, ciò richiederebbe una grande quantità di letture dallo storage e sarebbe quindi particolarmente costoso.} \\ \hline
						\textbf{Soluzione} & {Sfruttare il modifier \textit{view} di Solidity, che consente di leggere e aggregare i dati dallo \textit{storage} del contratto senza alcun costo associato. Le funzioni dichiarate con il modifier \textit{view} non sono autorizzate a scrivere nello \textit{storage} e quindi non modificano lo stato della blockchain. Poiché lo stato della blockchain rimane invariato, non è necessario trasmettere una transazione nella rete. Nessuna transazione significa nessun consumo di gas, il che rende gratuita la chiamata della funzione, purché sia chiamata esternamente e non da un altro contratto. In tal caso, sarebbe necessaria una transazione e verrebbe consumato del gas. Una funzione con tali caratteristiche permette di eseguire un lettura da diverse fonti, aggregare e ritornare i dati in un array definito in \textit{memory}, anziché nello \textit{storage}.} \\ \hline
						\textbf{Riconoscimento} & {Individuare la definizione di una funzione avente modifier \textit{view} che ritorni un array con locazione \textit{memory}.} \\ \hline
						\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:memory_array_building]{Appendice}.  \\ \hline
						\textbf{Riferimenti} & \cite[Memory Array Building]{fravoll} \cite[Limit Storage]{9050163} \\
					\end{tabular}
				};
				\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
			\end{tikzpicture}
			\caption{Specifiche Memory Array Building Pattern}
		\end{table}
	}
	{\subsection{String Equality Comparison Pattern}
		Lo \textit{String Equality Comparison} pattern propone un meccanismo per poter verificare l’uguaglianza di due stringhe in un modo che minimizzi il consumo medio del gas per un gran numero di input diversi.
		\begin{table}[H]
			\centering
			\begin{tikzpicture}
				\node (table) [inner sep=0pt] {
					\def\arraystretch{1.5}
					\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
						\textbf{Problema} & {Confrontare le stringhe in altri linguaggi di programmazione è un compito banale, vi sono metodi o pacchetti integrati che possono verificare l'uguaglianza di due input con una sola chiamata, ad esempio \textit{String1.equals(String2)} in Java. Solidity, nella sua versione 0.8.0.0, non supporta alcuna funzionalità di questo tipo al momento della stesura del presente documento.} \\ \hline
						\textbf{Soluzione} & {La soluzione proposta è basata sull'utilizzo di una funzione di hash per il confronto, opzionalmente combinata con un controllo della corrispondenza della lunghezza delle stringhe fornite, per eliminare fin dall'inizio le coppie con lunghezze differenti.} \\ \hline
						\textbf{Riconoscimento} & {Individuare un uguaglianza fra due risultati della funzione \textit{keccak256()}.} \\ \hline
						\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:string_equality_comparison]{Appendice}.  \\ \hline
						\textbf{Riferimenti} & \cite[String Equaliy Comparison]{fravoll} \\
					\end{tabular}
				};
				\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
			\end{tikzpicture}
			\caption{Specifiche String Equality Comparison Pattern}
		\end{table}
	}
	{\subsection{Tight Variable Packing Pattern}
	Il \textit{Tight Variable Packing} pattern propone un meccanismo per ottimizzare il consumo di gas nella memorizzazione e nella lettura variabili di dimensione statica.\par
	Lo storage in Ethereum è una struttura \textit{chiave-valore} con chiavi e valori di 32 byte ciascuno. Quando viene allocato lo storage di un contratto, tutte le variabili di dimensione statica, eccetto le mappature e gli array di dimensione dinamica, vengono memorizzate nello storage una dopo l'altra, nell'ordine in cui sono state dichiarate.\par I tipi di dati più comunemente utilizzati come \textit{byte32}, \textit{uint} e \textit{int} occupano esattamente uno slot da 32 byte, perciò vengono letti o memorizzati in un’unica operazione.\par
	Sarebbe, quindi, ottimale ordinare la dichiarazione dei tipi di dimensione statica più piccola, come \textit{byte16}, \textit{uint8} e così via, in modo che l’EVM possa raggrupparli in un singolo slot da 32 byte e operare su di essi con un'unica operazione, utilizzando meno memoria e risparmiando gas.
	\begin{table}[H]
		\centering
		\begin{tikzpicture}
			\node (table) [inner sep=0pt] {
				\def\arraystretch{1.5}
				\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
					\textbf{Problema} & {Salvare o leggere dati di dimensione inferiori a 32 byte può causare uno spreco di gas correlato all’esecuzione di operazioni di lettura e scrittura superflue su uno storage basato su slot di 32 byte.} \\ \hline
					\textbf{Soluzione} & {Ordinare la dichiarazione, dei tipi più piccoli come \textit{bytes16} \textit{uint8}, e così via, in modo che l’EVM possa raggrupparli in un singolo slot da 32 byte.} \\ \hline
					\textbf{Riconoscimento} & {Individuare la definizione di una \textit{struct} contenente tipi di dati la cui somma dello spazio occupato sia minore o uguale, quando possibile, a 32 byte.} \\ \hline
					\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:tight_variable_packing]{Appendice}.  \\ \hline
					\textbf{Riferimenti} & \cite[Tight Variable Packing]{fravoll} \cite[Packing Variables]{9050163} \\
				\end{tabular}
			};
			\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
		\end{tikzpicture}
		\caption{Specifiche Tight Variable Packing Pattern}
	\end{table}
}
}

{\section{Lifecycle Design Pattern}
	I Lifecycle design pattern propongono meccanismi per la creazione e la distruzione degli smart-contract. \par
	Si individuano i seguenti design pattern: \textit{Auto Deprecation} e \textit{Mortal}.
	
	{\subsection{Auto Deprecation Pattern}
		L’\textit{Auto Deprecation} pattern propone un meccanismo che, definito uno specifico quanto di tempo, permette di interrompere automaticamente, allo scadere del quanto di tempo, l'esecuzione di specifiche funzionalità del contratto.
		\begin{table}[H]
			\centering
			\begin{tikzpicture}
				\node (table) [inner sep=0pt] {
					\def\arraystretch{1.5}
					\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
						\textbf{Problema} & {Si immagini uno scenario d’uso come un evento a tempo, allo scadere di un quanto di tempo, lo smart-contract deve interrompere l’esecuzione della funzionalità relativa all'evento.} \\ \hline
						\textbf{Soluzione} & {Definire un quanto di tempo e un modifier che controlli la scadenza, applicare il modifier nella definizione delle funzioni soggette a scadenza.} \\ \hline
						\textbf{Riconoscimento} & {Data la libertà implementativa, il riconoscimento di questo design pattern si basa sulla ricerca della definizione e uso di una funzione di controllo della scadenza denominata \textit{expired()} e dei modifier relativi.} \\ \hline
						\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:auto_deprecation]{Appendice}.  \\ \hline
						\textbf{Riferimenti} & \cite[AutomaticDeprecation]{maxwoe} \cite[AutoDeprecation]{cjgdev} \\
					\end{tabular}
				};
				\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
			\end{tikzpicture}
			\caption{Specifiche Auto Deprecation Pattern}
		\end{table}
	}
	{\subsection{Mortal Pattern}
		Il \textit{Mortal} pattern propone un meccanismo terminare e distruggere un contratto.\par
		Poiché è la distruzione di un contratto è un operazione critica, la funzionalità è riservata al proprietario del contratto e per questo motivo l’accesso a tale metodo viene spesso gestito attraverso un Authorization pattern design.
		\begin{table}[H]
			\centering
			\begin{tikzpicture}
				\node (table) [inner sep=0pt] {
					\def\arraystretch{1.5}
					\begin{tabular}{p{0.30\linewidth} | p{0.65\linewidth}}
						\textbf{Problema} & {Generalmente, l'esistenza e l'esecuzione di un contratto sono legate all'esistenza della rete Ethereum stessa. Potrebbe, però, in certi casi, come la terminazione del servizio offerto, essere necessario terminare e distruggere il contratto.} \\ \hline
						\textbf{Soluzione} & {Solidity mette a disposizione la funzione \textit{selfdestruct(address)} che termina il contratto che la esegue, non prima di aver trasferito il fondo monetario del contratto all'indirizzo fornito come parametro.} \\ \hline
						\textbf{Riconoscimento} & {Individuare l'esecuzione della funzione \textit{selfdestruct(address)}. Al fine di evidenziare \textit{selfdestruct(address)} come fulcro del pattern design, l'elemento di autenticazione non viene considerato.} \\ \hline
						\textbf{Snippet di Codice\newline(Versione Semplificata)} & Il codice sorgente di riferimento è consultabile nell'\hyperref[appendix:mortal]{Appendice}.  \\ \hline
						\textbf{Riferimenti} & \cite[Mortal]{maxwoe} \cite[Mortal]{cjgdev} \\
					\end{tabular}
				};
				\draw [rounded corners=.5em] (table.north west) rectangle (table.south east);
			\end{tikzpicture}
			\caption{Specifiche Mortal Pattern}
		\end{table}
	}
}